Potential alternative rule for SecretKey

SPEC javax.crypto.SecretKey
OBJECTS 
	javax.crypto.SecretKey key;
	byte[] keyMaterial;
	javax.crypto.spec.PBEKeySpec pbekeyspec;
	javax.crypto.KeyGenerator
EVENTS
	cons1: this = secretKeyFactory.generateSecret(_)
	cons2: this = keyGen.generateKey(); //depends on KeyGenerator, required pred?
	cons := cons1 | cons2;
	d: destroy();
	ge: keyMaterial = getEncoded();
ORDER
	cons, ge*, d?
REQUIRES
	secretKeyFactory[secretKeyFactory];
	keyGenerator[keyGen];
	
ENSURES
	preparedKeyMaterial[keyMaterial] after ge;
NEGATES
	generatedKey[this, _] after d;
	
	
PBEKeySpec pBEKeySpec = new PBEKeySpec(password.toCharArray(), salt, 10000, 256);

Case A:
SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance("PBKDF2WithSHA256");
Assertions.notHasEnsuredPredicate(pBEKeySpec);
SecretKey generateSecret = secretKeyFactory.generateSecret(pBEKeySpec);
Assertions.notHasEnsuredPredicate(generateSecret);
byte[] keyMaterial = generateSecret.getEncoded();
Assertions.notHasEnsuredPredicate(keyMaterial);
SecretKey encryptionKey = new SecretKeySpec(keyMaterial, "AES");
//pBEKeySpec.clearPassword();
Assertions.notHasEnsuredPredicate(encryptionKey);

Case B:
KeyGenerator keygen = KeyGenerator.getInstance("AES");
Assertions.extValue(0);
keygen.init(128);
Assertions.extValue(0);
SecretKey key = keygen.generateKey();

Assertions.hasEnsuredPredicate(key);
Assertions.mustBeInAcceptingState(keygen);